(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{548:function(e,n,t){var content=t(556);content.__esModule&&(content=content.default),"string"==typeof content&&(content=[[e.i,content,""]]),content.locals&&(e.exports=content.locals);(0,t(18).default)("2f51735f",content,!0,{sourceMap:!1})},555:function(e,n,t){"use strict";t(548)},556:function(e,n,t){var r=t(17)(!1);r.push([e.i,"div[data-v-476d19a1]{padding:0 0 0 30px}",""]),e.exports=r},557:function(e,n,t){"use strict";var r={mounted:function(){window.RunKit.createNotebook({element:this.$el,source:this.$slots.default[0].text,nodeVersion:"lts"})}},o=(t(555),t(83)),component=Object(o.a)(r,(function(){var e=this.$createElement;return(this._self._c||e)("div")}),[],!1,null,"476d19a1",null);n.a=component.exports},603:function(e,n,t){"use strict";t.r(n);var r={components:{RunkitEmbedded:t(557).a},data:function(){return{isVisible:!1}}},o=t(83),l=t(177),c=t.n(l),d=t(612),v=t(549),_=t(547),f=t(543),component=Object(o.a)(r,(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("v-container",[t("v-card",[t("v-card-title",{staticClass:"headline primary--text"},[e._v("L'asynchronisme avec les callbacks")]),e._v(" "),t("v-card-text",[t("v-card-title",{staticClass:"subheading primary--text"},[e._v("Pourquoi l'asynchronisme en JavaScript ?")]),e._v(" "),t("p",[e._v("\n            JavaScript (executé par V8 en Node.js) est mono-thread, c'est à dire que :\n            "),t("ul",[t("li",[e._v("il n'y a pas plus d'une instruction executée à la fois ;")]),e._v(" "),t("li",[e._v("\n                pour un serveur web, toutes les requêtes HTTP entrantes vont être traitées par le même thread."),t("br")])])]),e._v(" "),t("v-alert",{attrs:{outlined:"",value:!0,color:"error",icon:"warning",outline:""}},[e._v("\n            Il est important de ne pas bloquer le thread trop longtemps pour ne pas impacter les autres requêtes.\n          ")]),e._v(" "),t("v-card-title",{staticClass:"subheading primary--text"},[e._v("Les fonctions asynchrones")]),e._v(" "),t("p",[e._v("\n            Ainsi, pour les opérations d'entrées/sorties (lecture/écriture de fichier, requête HTTP...), il faut utiliser des fonctions asynchrones afin de ne pas bloquer le thread."),t("br"),e._v("\n            La convention est que :\n            "),t("ul",[t("li",[e._v("les fonctions asynchrones acceptent en dernier paramètre (souvent nommé "),t("code",[e._v("done")]),e._v(") une fonction (appelée "),t("strong",[e._v("callback")]),e._v(") ;")]),e._v(" "),t("li",[e._v("la fonction "),t("strong",[e._v("callback")]),e._v(" sera appelée une fois le traitement asynchrone terminée, et accepte comme premier paramètre une erreur.")])])]),e._v(" "),t("p",[e._v("\n            L'exécution d'une fonction asynchrone ne bloque pas sur l'opération I/O : celle-ci est faite en arrière-plan par Node.js et l'exécution du code JavaScript continue."),t("br"),e._v("\n            A la fin de l'opération I/O, Node.js ("),t("code",[e._v("libuv")]),e._v(" plus précisément) placera le callback dans un liste d'attente, qui sera dépilée et exécutée lorsque le thread sera disponible\n            (les instructions en cours d'exécution ne sont pas interrompues).\n\n            "),t("v-alert",{attrs:{outlined:"",value:!0,color:"info",icon:"info",outline:""}},[e._v("\n              Node.js propose également des fonctions synchrones pour effectuer des opérations I/O : il ne faut pas les utiliser afin de ne pas dégrader les performances."),t("br"),e._v("\n              Il existe cependant quelques rares cas où il peut être nécessaire de les utiliser (par exemple au démarrage de l'application).\n            ")])],1),e._v(" "),t("p",[e._v("\n            Exemple de code asynchrone :\n            "),e._v(" "),t("runkit-embedded",[e._v("\nconst fs = require(\"fs\");\nconst { join } = require(\"path\");\n\nfs.readdir(__dirname, (err, dirs) => {\n    if(err) {\n        console.log('cannot read dir');\n        return;\n    }\n    console.log(`fichiers dans le dossier courant : ${dirs.join()}`);\n});\nfs.stat(join(__dirname, 'package.json'), (err, stat) => {\n    if(err) {\n        console.log('cannot read file package.json');\n        return;\n    }\n    console.log(`taille du fichier package.json : ${stat.size}`);\n});\nconsole.log('fin du fichier');\n            ")]),e._v(" "),e._v("\n\n            A noter :\n            "),t("ul",[t("li",[t("code",[e._v("fin du fichier")]),e._v(" sera toujours la première ligne affichée en console ;")]),e._v(" "),t("li",[e._v("les 2 lectures disques sont faites en parallèle ;")]),e._v(" "),t("li",[e._v("l'ordre des 2 autres lignes n'est pas défini.")])])],1),e._v(" "),t("p",[e._v("\n            Exemple de code synchrone :\n            "),e._v(" "),t("runkit-embedded",[e._v("\nconst fs = require(\"fs\");\nconst { join } = require(\"path\");\n\ntry {\n    const dirs = fs.readdirSync(__dirname)\n    console.log(`fichiers dans le dossier courant : ${dirs.join()}`);\n} catch (err) {\n    console.log('cannot read dir');\n}\n\ntry {\n    const stat = fs.statSync(join(__dirname, 'package.json'))\n    console.log(`taille du fichier package.json : ${stat.size}`);\n} catch (err) {\n    console.log('cannot read file package.json');\n}\n\nconsole.log('fin du fichier');\n            ")]),e._v(" "),e._v("\n\n            A noter :\n            "),t("ul",[t("li",[e._v("les lignes sont affichées dans l'ordre du code ;")]),e._v(" "),t("li",[e._v("les 2 lectures disques sont faites en séquentiel ;")]),e._v(" "),t("li",[e._v("NodeJS ne peut rien faire d'autre pendant que le code est executé.")])])],1),e._v(" "),t("v-card-title",{staticClass:"subheading primary--text"},[e._v("Asynchronisme vs. synchronisme")]),e._v(" "),t("p",[e._v("\n            Le code synchrone :\n            "),t("ul",[t("li",[e._v("s'exécute dans l'ordre dans lequel il est écrit, ce qui le rend plutôt simple à comprendre et à lire ;")]),e._v(" "),t("li",[e._v("\n                par contre, dans un contexte de forte concurrence : beaucoup de threads vont être créés et\n                le système d'exploitation va devoir sans cesse passer d'un thread à l'autre (ce qu'on appelle la "),t("a",{attrs:{href:"https://fr.wikipedia.org/wiki/Commutation_de_contexte"}},[e._v("commutation de contexte")]),e._v(").\n                Dans le cas d'une application qui fait beaucoup d'I/O, le cumul de toutes ces commutations de contexte peut représenter une charge CPU relativement importante.\n              ")])])]),e._v(" "),t("p",[e._v("\n            Le code asynchrone :\n            "),t("ul",[t("li",[e._v("ne s'exécute pas dans l'ordre dans lequel il est écrit, ce qui le rend plutôt difficile à appréhender ;")]),e._v(" "),t("li",[e._v("il n'y a qu'un seul thread, donc pas de commutation de contexte, ce qui est plus performant dans un contexte où il y a beaucoup d'I/O ;")]),e._v(" "),t("li",[e._v("les opérations I/O sont (pour la plupart) gérées avec des méchanismes de traitement d'évènements (par exemple : "),t("code",[e._v("epoll")]),e._v(" sous Linux...)")])])])],1),e._v(" "),t("v-card-text",[t("v-card-title",{staticClass:"subheading secondary--text"},[e._v("TP Fil rouge")]),e._v(" "),t("p",[t("ol",[t("li",[e._v("\n                Créer un module "),t("code",[e._v("app/fs-utils.js")]),e._v(" qui exporte une fonction "),t("code",[e._v("getDirContent()")]),e._v(" :\n                "),t("ul",[t("li",[e._v("la fonction accepte 2 paramètres : le chemin absolu du dossier et une fonction callback ;")]),e._v(" "),t("li",[e._v("la fonction invoque le callback avec 2 paramètres : une erreur et un tableau contenant les chemins absolus des fichiers et sous-dossiers.")])])]),e._v(" "),t("li",[e._v("\n                Tester la fonction en l'invoquant avec les cas suivants :\n                "),t("ul",[t("li",[e._v("le chemin désigne un dossier qui existe ;")]),e._v(" "),t("li",[e._v("le chemin désigne un fichier ;")]),e._v(" "),t("li",[e._v("le chemin designe un dossier qui n'existe pas.")])])])])])],1)],1)],1)}),[],!1,null,null,null);n.default=component.exports;c()(component,{VAlert:d.a,VCard:v.a,VCardText:_.a,VCardTitle:_.b,VContainer:f.a})}}]);